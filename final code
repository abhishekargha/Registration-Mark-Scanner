// Define color sensor pins
#define S0 4
#define S1 5
#define S2 6
#define S3 7
#define sensorOut 8
int st;

// Calibration Values
// Get these from Calibration Sketch
int redMin = 16;
int redMax = 126;
int greenMin = 17;
int greenMax = 140;
int blueMin = 13;
int blueMax = 118;

// Variables for Color Pulse Width Measurements
int redPW = 0;
int greenPW = 0;
int bluePW = 0;

// Variables for final Color values
int redValue;
int greenValue;
int blueValue;

// Time delay parameters
unsigned long colorWaitTime; // Time to wait for the next color
unsigned long lastColorTime = 0; // Timestamp of the last detected color

void setup() {
  // Set S0 - S3 as outputs
  pinMode(S0, OUTPUT);
  pinMode(S1, OUTPUT);
  pinMode(S2, OUTPUT);
  pinMode(S3, OUTPUT);
  pinMode(12, OUTPUT);
  pinMode(3, INPUT);

  // Set Sensor output as input
  pinMode(sensorOut, INPUT);

  // Set Frequency scaling to 20%
  digitalWrite(S0, HIGH);
  digitalWrite(S1, LOW);

  // Setup Serial Monitor
  Serial.begin(9600);

  // Set the initial color wait time (adjust as needed)
  colorWaitTime = 5000; // 5 seconds initially
}

void loop() {
  st = digitalRead(3);
  if (st == 1) {
    // Read Red value
    redPW = getRedPW();
    redValue = map(redPW, redMin, redMax, 255, 0);
    delay(200);

    // Read Green value
    greenPW = getGreenPW();
    greenValue = map(greenPW, greenMin, greenMax, 255, 0);
    delay(200);

    // Read Blue value
    bluePW = getBluePW();
    blueValue = map(bluePW, blueMin, blueMax, 255, 0);
    delay(200);

    // Print output to Serial Monitor
    Serial.print("Red = ");
    Serial.print(redValue);
    Serial.print(" - Green = ");
    Serial.print(greenValue);
    Serial.print(" - Blue = ");
    Serial.println(blueValue);

    // Check for the presence of the desired color
    if (isColorPresent(redValue, greenValue, blueValue)) {
      // Check if enough time has passed since the last color detection
      unsigned long currentTime = millis();
      if (currentTime - lastColorTime >= colorWaitTime) {
        // Perform actions associated with the detected color
        performColorActions(redValue, greenValue, blueValue);

        // Update the last color detection timestamp
        lastColorTime = currentTime;
      }
    }
  }
}

int getRedPW() {
  digitalWrite(S2, LOW);
  digitalWrite(S3, LOW);
  int PW = pulseIn(sensorOut, LOW);
  return PW;
}

int getGreenPW() {
  digitalWrite(S2, HIGH);
  digitalWrite(S3, HIGH);
  int PW = pulseIn(sensorOut, LOW);
  return PW;
}

int getBluePW() {
  digitalWrite(S2, LOW);
  digitalWrite(S3, HIGH);
  int PW = pulseIn(sensorOut, LOW);
  return PW;
}

// Function to check if the detected color matches the target color
bool isColorPresent(int red, int green, int blue) {
  // Adjust these threshold values based on your calibration
  return (red >= 100 && green >= 100 && blue >= 100);
}

// Function to perform actions based on the detected color
void performColorActions(int red, int green, int blue) {
  // Implement actions specific to each color
  if (red >= 100 && green >= 100 && blue >= 100) {
    // This is an example, replace with your specific actions
    // e.g., adjust machine settings, wait for the next color, etc.
    delay(5000); // Adjust the delay based on the speed of the flexographic machine
    Serial.println("Performing actions for the detected color.");
  }
}
